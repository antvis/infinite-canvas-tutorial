import{_ as e,c as r,o as a,a6 as t,as as i}from"./chunks/framework.B2LRalDI.js";const _=JSON.parse('{"title":"什么是无限画布？","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/what-is-an-infinite-canvas.md","filePath":"zh/guide/what-is-an-infinite-canvas.md"}'),l={name:"zh/guide/what-is-an-infinite-canvas.md"},n=t('<h1 id="什么是无限画布" tabindex="-1">什么是无限画布？ <a class="header-anchor" href="#什么是无限画布" aria-label="Permalink to &quot;什么是无限画布？&quot;">​</a></h1><p><a href="https://infinitecanvas.tools/" target="_blank" rel="noreferrer">infinitecanvas</a> 对“无限”的描述如下：</p><ul><li>高扩展性。用户可以以非线形的形式自由组织内容结构。</li><li>缩放。模拟真实世界中的“放大”纵览全局和“缩小”观察细节。</li><li>直接操作。提供对于基础图形的直观编辑能力，包括移动、成组、修改样式等。</li><li>实时协作。</li></ul><p>你一定见过甚至使用过各种包含无限画布的应用，<a href="https://infinitecanvas.tools/" target="_blank" rel="noreferrer">infinitecanvas</a> 上就展示了从设计工具到创意画板在内的众多案例，其中不乏一些知名产品包括 <a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a>、<a href="https://digest.browsertech.com/archive/browsertech-digest-how-modyfi-is-building-with/" target="_blank" rel="noreferrer">Modyfi</a>、<a href="https://github.com/flxzt/rnote" target="_blank" rel="noreferrer">rnote</a>、<a href="https://github.com/tldraw/tldraw" target="_blank" rel="noreferrer">tldraw</a>、<a href="https://github.com/excalidraw/excalidraw" target="_blank" rel="noreferrer">excalidraw</a>等等。</p><p>作为一个前端，我对其中涉及到的渲染技术很感兴趣。尽管 <a href="https://github.com/tldraw/tldraw" target="_blank" rel="noreferrer">tldraw</a>、<a href="https://github.com/excalidraw/excalidraw" target="_blank" rel="noreferrer">excalidraw</a> 等普遍使用易用性更高的 Canvas2D / SVG 技术，但 JS 和 Rust 生态中也有很多编辑器、设计工具使用更底层的渲染技术对 2D 图形进行 GPU 加速，以获得更好的性能和体验：</p><ul><li><a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a> 使用 C++ 编写了一个 tile-based 的渲染引擎，编译成 WASM 后调用 WebGL 渲染</li><li><a href="https://digest.browsertech.com/archive/browsertech-digest-how-modyfi-is-building-with/" target="_blank" rel="noreferrer">Modyfi</a> 使用了 Rust 生态中的 <a href="https://wgpu.rs/" target="_blank" rel="noreferrer">wgpu</a>，同样编译成 WASM 后调用 WebGL2 渲染</li><li><a href="https://zed.dev/blog/videogame" target="_blank" rel="noreferrer">Zed</a> 使用 GPUI 渲染矩形、阴影、文本、图片等 UI。</li><li><a href="https://github.com/linebender/vello" target="_blank" rel="noreferrer">vello</a> 和 <a href="https://github.com/linebender/xilem" target="_blank" rel="noreferrer">xilem</a> 实验性地使用了 Compute Shader 进行 2D 渲染。</li></ul><p>因此在这个教程中，我希望实现以下特性：</p><ul><li>使用 <a href="https://github.com/antvis/g-device-api" target="_blank" rel="noreferrer">@antv/g-device-api</a> 作为硬件抽象层，支持 WebGL1/2 和 WebGPU。</li><li>参考 <a href="https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2?gi=e5acafcf219d" target="_blank" rel="noreferrer">mapbox</a> 和 <a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a>，尝试使用 Tile-based 渲染。</li><li>使用 SDF 渲染圆、椭圆、矩形等。</li><li>GPU 加速的文本和贝塞尔曲线渲染。</li><li>使用 <a href="https://github.com/rough-stuff/rough" target="_blank" rel="noreferrer">rough.js</a> 支持手绘风格。</li><li>使用 CRDT 支持协同 <a href="https://yjs.dev/" target="_blank" rel="noreferrer">Yjs</a>。</li></ul><p>未来我希望将画布的渲染部分用 Rust 重写，目前项目的完成度还比较低：</p><ul><li><a href="https://wgpu.rs/" target="_blank" rel="noreferrer">wgpu</a> 是非常可靠的硬件抽象层，甚至可以为 <a href="https://github.com/linebender/piet" target="_blank" rel="noreferrer">piet</a> 实现后端。</li><li>Shader 基本可以复用。</li><li>手绘风格可以使用 <a href="https://github.com/orhanbalci/rough-rs" target="_blank" rel="noreferrer">rough-rs</a>。</li><li><a href="https://github.com/y-crdt/y-crdt" target="_blank" rel="noreferrer">y-crdt</a> 是 <a href="https://yjs.dev/" target="_blank" rel="noreferrer">Yjs</a> 的 Rust 实现。</li></ul><figure><img src="'+i+'" alt=""><figcaption>rust stack</figcaption></figure><p>让我们开始吧！</p>',12),o=[n];function s(h,f,g,d,c,b){return a(),r("div",null,o)}const u=e(l,[["render",s]]);export{_ as __pageData,u as default};
