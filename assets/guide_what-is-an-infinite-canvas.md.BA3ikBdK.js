import{_ as e,c as r,o as t,a6 as a,as as i}from"./chunks/framework.B2LRalDI.js";const b=JSON.parse('{"title":"What is an Infinite Canvas?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/what-is-an-infinite-canvas.md","filePath":"guide/what-is-an-infinite-canvas.md"}'),n={name:"guide/what-is-an-infinite-canvas.md"},o=a('<h1 id="what-is-an-infinite-canvas" tabindex="-1">What is an Infinite Canvas? <a class="header-anchor" href="#what-is-an-infinite-canvas" aria-label="Permalink to &quot;What is an Infinite Canvas?&quot;">â€‹</a></h1><p>The term &quot;infinite&quot; in <a href="https://infinitecanvas.tools/" target="_blank" rel="noreferrer">infinitecanvas</a> is described as follows:</p><ul><li>High scalability. Users can freely organize content structures in a non-linear fashion.</li><li>Zooming. Emulates the &quot;zoom in&quot; to get an overview and &quot;zoom out&quot; to observe details as in the real world.</li><li>Direct manipulation. Provides intuitive editing capabilities for basic shapes, including moving, grouping, and modifying styles.</li></ul><p>The <a href="https://infinitecanvas.tools/" target="_blank" rel="noreferrer">infinitecanvas</a> showcases numerous examples ranging from design tools to creative boards, including some well-known products such as: <a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a>, <a href="https://digest.browsertech.com/archive/browsertech-digest-how-modyfi-is-building-with/" target="_blank" rel="noreferrer">Modyfi</a>, <a href="https://github.com/flxzt/rnote" target="_blank" rel="noreferrer">rnote</a>, <a href="https://github.com/tldraw/tldraw" target="_blank" rel="noreferrer">tldraw</a>, <a href="https://github.com/excalidraw/excalidraw" target="_blank" rel="noreferrer">excalidraw</a> and so on.</p><p>As a front-end developer, I am very interested in the rendering technologies involved. Although tldraw, excalidraw, and others generally use more user-friendly technologies like Canvas2D/SVG, there are also many editors and design tools in the JS and Rust ecosystems that use more low-level rendering technologies for 2D graphics with GPU acceleration to achieve better performance and experience:</p><ul><li><a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a> uses a tile-based rendering engine written in C++, compiled into WASM and then calls WebGL for rendering.</li><li><a href="https://digest.browsertech.com/archive/browsertech-digest-how-modyfi-is-building-with/" target="_blank" rel="noreferrer">Modyfi</a> uses <a href="https://wgpu.rs/" target="_blank" rel="noreferrer">wgpu</a> from the Rust ecosystem, also compiled into WASM and then calls WebGL2 for rendering.</li><li><a href="https://zed.dev/blog/videogame" target="_blank" rel="noreferrer">Zed</a> uses GPUI to render rectangles, shadows, text, images, and other UI elements.</li><li><a href="https://github.com/linebender/vello" target="_blank" rel="noreferrer">Vello</a> and <a href="https://github.com/linebender/xilem" target="_blank" rel="noreferrer">xilem</a> experimentally use Compute Shader for 2D rendering.</li></ul><p>Therefore, in this tutorial, I hope to implement the following features:</p><ul><li>Use <a href="https://github.com/antvis/g-device-api" target="_blank" rel="noreferrer">@antv/g-device-api</a> as a hardware abstraction layer, supporting WebGL1/2 and WebGPU.</li><li>Referencing <a href="https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2?gi=e5acafcf219d" target="_blank" rel="noreferrer">mapbox</a> and <a href="https://madebyevan.com/figma/building-a-professional-design-tool-on-the-web/" target="_blank" rel="noreferrer">Figma</a>, attempt to use tile-based rendering.</li><li>Use SDF (Signed Distance Field) rendering for circles, ellipses, rectangles, etc.</li><li>GPU-accelerated text and Bezier curve rendering.</li><li>Use <a href="https://github.com/rough-stuff/rough" target="_blank" rel="noreferrer">rough.js</a> to support hand-drawn styles.</li><li>Use CRDT (Conflict-free Replicated Data Type) to support collaborative <a href="https://yjs.dev/" target="_blank" rel="noreferrer">Yjs</a>.</li></ul><p>I hope to rewrite the rendering part of the canvas with Rust in the future, but the current project completion is still relatively low:</p><ul><li><a href="https://wgpu.rs/" target="_blank" rel="noreferrer">wgpu</a> is a very reliable hardware abstraction layer, which can even implement the backend for <a href="https://github.com/linebender/piet" target="_blank" rel="noreferrer">piet</a>.</li><li>Shaders can basically be reused.</li><li>Hand-drawn styles can use <a href="https://github.com/orhanbalci/rough-rs" target="_blank" rel="noreferrer">rough-rs</a>.</li><li><a href="https://github.com/y-crdt/y-crdt" target="_blank" rel="noreferrer">y-crdt</a> is the Rust implementation of <a href="https://yjs.dev/" target="_blank" rel="noreferrer">Yjs</a>.</li></ul><figure><img src="'+i+'" alt=""><figcaption>rust stack</figcaption></figure><p>Let&#39;s get started!</p>',12),l=[o];function s(h,d,c,g,f,p){return t(),r("div",null,l)}const m=e(n,[["render",s]]);export{b as __pageData,m as default};
